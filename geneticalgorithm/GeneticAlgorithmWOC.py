import random
import operator
import time
import math
import matplotlib.pyplot as plt
import sys
import datetime
import numpy as np
sys.path.append('../')
from TSPSol import dist,load,plotgraph
from progress.bar import Bar
totalpoints,coordslist=load('../Random222.tsp')
totalpointsInt = int(totalpoints)
possibletourpath = list(range(1,totalpointsInt+1))
print("starttime",datetime.datetime.now())

# A list to store the population i.e the list of routes in this problem statement

a= np.array([[0]*(totalpointsInt+2)]*(totalpointsInt+2))

# get an edge
# find the next possible edge in the list of edges
# if there is no edge available ?
# if there is more than one edge ?
# if there is only one edge


def closestpoint(point):
    distances={}
    for i in range(1,totalpointsInt+1):
        if point !=i:
           distances[i]=dist(point,i,coordslist)
    return sorted(distances.items(),key=operator.itemgetter(1))



def findlink(point,commonedges,tourpath):
    found = False

    for edge in commonedges:
        if point in edge:
            ind = edge.index(point)
            if ind == 0:
                index =1
            else :
                index =0
            #print("Edge %s to be connected for the point %d  "%(edge[index],point))
            found=True
            return edge[index],edge
            #commonedges.remove(edge)
            #findlink(edge[index],commonedges)
    if not found :
            closestp=0
            for k,v in closestpoint(point):
                if k not in tourpath:
                    closestp=k
                    break
                else:
                    continue
            return closestp, 0
        # for k,v in closestpoint():
        #     print(v)
        # if closestpoint(point) not in tourpath:
        #     print("Couldn't find an edge for the point: %d to join but the closest point to it is %s"%((point),closestpoint(point)))
        #     #findlink(closestpoint(point),commonedges)
        #     return closestpoint(point),0
        # else :
        #     print("the closest point you have found is already in the tourpath so should look for next best point")


def connectedges(commonedges,startingpoint):
    tourpath=[]
    nextpoint=startingpoint
    tourpath.append(nextpoint)
    #print(possibletourpath)
    while not all(elem in tourpath for elem in possibletourpath):
        #print(tourpath)
        nextpoint,edge = findlink(nextpoint,commonedges,tourpath)
        if edge !=0:
            commonedges.remove(edge)
        tourpath.append(nextpoint)

    tourpath.append(startingpoint)
    print(tourpath)
    print("distance of the route generated by the wisdom of crowds",distanceofRoute(tourpath))





def aggregate(crowds,startingpoint):
    for route in crowds:
        a[route[0],route[-1]] = a[route[0],route[-1]]+1
        for i in range(len(route)-1):
            a[route[i],route[i+1]] = a[route[i],route[i+1]]+1

    rows= a.shape[0]
    cols = a.shape[1]
    commonedges= []
    for i in range(rows):
        for j in range(cols):
            if a[i,j] > 27:
                #print("Matrix (%d,%d) : Value : (%d)"%(i,j,a[i,j]))
                commonedges.append([i,j])
    print("Length of the common edges of the top 30 individual tours",len(commonedges))
    #print(commonedges)
    connectedges(commonedges,startingpoint)



def plotpoints():
    for point in coordslist:
        xs=point[1]
        ys=point[2]
        plt.plot(xs, ys, color='green', linewidth=0, marker='o', markerfacecolor='blue', markersize=5)
        plt.annotate(point[0],(xs, ys), textcoords='data')
    plt.show()


def calmidpoint():

    x=sum(coordslist[1])/2
    y=sum(coordslist[2])/2
    return [800,x,y]


#This is to print all the routes from the list of routes in a more readable fashion
def printRoute(listofRoutes):
    for idx,route in enumerate(listofRoutes):
        print("Route: %d, Length of Route: %d,Distance of Route: %d, Fitness of route: %f \n %s"%(idx,len(route),distanceofRoute(route),calcfitness(route),route))


#Function to return of a given route
def distanceofRoute(route):
    distance =0

    #print("Distance calculated for the route",route)
    for index in range(0,len(route)-1):
        distance=distance+dist(route[index],route[index+1],coordslist)

    distance=distance+dist(route[0],route[-1],coordslist)
    return distance

# This function is to return a random individual route from the list of input cities
def createroute():
    cityList = list(range(1, totalpointsInt + 1))
    return random.sample(cityList,len(cityList))

#This method is to calculate the angle formed by the city with the origin (0,0)
def calctheta(city):
    x= coordslist[city-1][1]
    y= coordslist[city-1][2]
    degree=math.degrees(math.atan(x/y))
    return degree

#this method is to calculate the distance from the origin to city
def calcr(city):
    x = coordslist[city - 1][1]
    y = coordslist[city - 1][2]
    return math.sqrt( x*x + y*y)



#Sorting a route based on the angle formed by the point with the origin(0,0)
def sorttheta(route):
    theta = {}
    stheta = []

    for city in route:
        theta[calctheta(city)] = city

    for k, v in sorted(theta.items()):
        # print(k)
        stheta.append(v)

    return stheta


#Sorting a route based on their radius form the origin(0,0)
def sortr(route):
    r = {}
    sr = []
    for city in route:
        r[calcr(city)] = city

    for k,v in sorted(r.items()):
        sr.append(v)

    return sr

#This function is to return population(size based on given input) of routes
def createPopulation(popsize):
    population=[]
    i=0
    while i < popsize-4:
        population.append(createroute())
        i+=1
    population.append([190, 184, 48, 179, 192, 57, 168, 136, 170, 175, 122, 202, 73, 106, 36, 96, 165, 111, 130, 185, 173, 80, 45, 145, 49, 42, 105, 150, 47, 167, 64, 98, 198, 59, 7, 24, 176, 171, 221, 46, 129, 123, 142, 181, 207, 201, 58, 4, 134, 143, 109, 35, 14, 79, 21, 119, 101, 39, 69, 166, 37, 95, 19, 164, 131, 92, 84, 158, 50, 29, 154, 112, 152, 218, 43, 72, 3, 89, 91, 140, 66, 99, 10, 135, 151, 215, 191, 77, 27, 33, 115, 56, 186, 162, 194, 204, 213, 52, 210, 90, 137, 13, 74, 183, 206, 34, 40, 208, 197, 161, 141, 76, 26, 2, 6, 71, 118, 51, 16, 41, 61, 124, 188, 159, 128, 219, 182, 195, 32, 22, 82, 67, 8, 127, 30, 125, 196, 214, 63, 20, 75, 17, 78, 187, 60, 55, 177, 209, 83, 86, 212, 205, 217, 139, 23, 81, 163, 199, 149, 133, 120, 9, 110, 160, 103, 216, 100, 132, 156, 11, 12, 114, 5, 44, 153, 25, 116, 88, 28, 148, 107, 146, 62, 180, 178, 222, 97, 54, 1, 70, 94, 65, 200, 104, 126, 147, 203, 15, 211, 193, 108, 93, 102, 172, 113, 85, 138, 174, 220, 68, 87, 121, 155, 169, 38, 18, 157, 53, 31, 117, 189, 144, 190])
    #population.append([107, 146, 62, 180, 178, 110, 9, 120, 133, 149, 81, 199, 163, 23, 139, 217, 205, 212, 86, 83, 209, 177, 55, 187, 78, 17, 75, 123, 20, 63, 58, 214, 196, 125, 134, 30, 127, 8, 67, 21, 119, 101, 39, 131, 19, 164, 92, 69, 166, 37, 95, 84, 158, 50, 29, 154, 112, 152, 43, 218, 206, 72, 3, 89, 91, 140, 66, 99, 10, 135, 151, 215, 191, 77, 27, 33, 115, 56, 186, 162, 194, 204, 213, 52, 210, 90, 137, 13, 74, 183, 34, 40, 161, 189, 197, 144, 208, 141, 76, 26, 2, 6, 71, 118, 51, 41, 16, 188, 159, 128, 61, 124, 219, 182, 195, 32, 22, 82, 79, 14, 35, 109, 143, 4, 201, 207, 142, 181, 129, 60, 46, 221, 171, 24, 7, 59, 198, 98, 64, 167, 47, 176, 150, 105, 42, 145, 49, 45, 80, 173, 185, 111, 130, 165, 96, 36, 202, 73, 170, 106, 122, 175, 136, 168, 57, 192, 179, 48, 184, 31, 190, 117, 53, 38, 157, 169, 68, 220, 87, 155, 121, 172, 113, 174, 138, 85, 102, 18, 15, 193, 93, 108, 211, 147, 126, 203, 104, 200, 65, 94, 70, 1, 103, 97, 222, 132, 54, 100, 216, 160, 110, 156, 132, 11, 114, 12, 11, 25, 88, 28, 116, 148, 107, 153, 44, 5, 107])
    #population.append([204, 213, 52, 210, 90, 137, 13, 74, 183, 34, 40, 161, 189, 197, 144, 208, 141, 76, 26, 2, 6, 71, 118, 51, 61, 16, 41, 159, 128, 188, 124, 219, 182, 195, 32, 22, 82, 67, 8, 127, 30, 134, 125, 196, 214, 58, 63, 20, 123, 75, 17, 78, 187, 55, 177, 209, 83, 86, 212, 205, 217, 139, 23, 163, 199, 81, 149, 133, 120, 9, 110, 160, 103, 216, 100, 54, 156, 132, 114, 5, 44, 153, 116, 28, 25, 88, 148, 107, 146, 62, 180, 178, 12, 11, 222, 97, 1, 70, 94, 65, 200, 147, 104, 126, 93, 203, 211, 108, 15, 18, 193, 102, 85, 138, 113, 174, 172, 121, 87, 155, 220, 68, 169, 157, 38, 53, 31, 190, 117, 184, 48, 179, 192, 57, 168, 136, 175, 122, 106, 170, 73, 202, 36, 96, 165, 130, 111, 185, 173, 80, 45, 49, 145, 42, 105, 150, 176, 47, 64, 167, 98, 198, 59, 7, 24, 171, 221, 46, 60, 129, 181, 142, 207, 201, 4, 143, 109, 35, 14, 79, 119, 21, 101, 39, 131, 19, 164, 92, 69, 166, 37, 95, 84, 158, 50, 29, 154, 112, 152, 43, 218, 72, 206, 3, 89, 91, 140, 66, 99, 10, 135, 151, 215, 191, 77, 27, 33, 115, 56, 186, 162, 194, 204])
    population.append([59, 24, 171, 221, 46, 60, 129, 181, 142, 207, 201, 4, 143, 109, 35, 14, 79, 119, 21, 101, 39, 166, 69, 164, 92, 19, 131, 37, 95, 29, 84, 158, 50, 154, 112, 152, 43, 34, 72, 206, 3, 89, 91, 140, 66, 99, 10, 135, 215, 151, 191, 77, 27, 33, 115, 56, 186, 162, 90, 137, 213, 210, 204, 52, 194, 13, 74, 183, 218, 40, 197, 208, 189, 161, 144, 141, 76, 26, 2, 6, 71, 16, 41, 118, 51, 61, 159, 128, 188, 124, 219, 22, 195, 182, 32, 82, 67, 8, 127, 30, 134, 125, 196, 214, 58, 63, 20, 123, 75, 17, 78, 187, 55, 177, 209, 83, 86, 212, 205, 217, 139, 23, 163, 199, 81, 149, 133, 120, 9, 110, 160, 216, 103, 100, 54, 156, 132, 114, 5, 44, 153, 116, 25, 28, 88, 148, 107, 146, 62, 180, 178, 12, 11, 222, 97, 1, 70, 94, 65, 200, 147, 104, 126, 93, 211, 203, 108, 15, 38, 193, 85, 102, 138, 113, 174, 172, 121, 87, 155, 220, 68, 169, 157, 18, 53, 31, 190, 117, 184, 48, 179, 192, 57, 168, 136, 175, 106, 122, 170, 73, 202, 36, 96, 165, 130, 111, 185, 173, 80, 45, 49, 145, 42, 105, 150, 176, 47, 64, 167, 98, 198, 7, 59])
    population.append(sorttheta(population[0]))
    population.append(sortr(population[0]))
    # print(stheta)
    #print(distanceofRoute(sorttheta(population[0])))
    #print(distanceofRoute(sortr(population[0])))
    # print(distanceofRoute(population[0]))
    return population

#print(coordslist)

createPopulation(5)
#This function is to return the fitness of each individual route
def calcfitness(route):
    distance=distanceofRoute(route)
    return (1/distance)*100000



def findtoproutes(rankedroutes,size,pop):
    toproutes=[]
    for key,v in rankedroutes:
        toproutes.append(pop[key])
    return toproutes[:size]


#print(population)
#This function is to return a dictionary { 'population index' : ' fitness value' } sorted on fitness results
def rankroutes(population):
    fitnessresults={}
    for idx,route in enumerate(population):
        fitnessresults[idx]=calcfitness(route)

    return sorted(fitnessresults.items(),key=operator.itemgetter(1),reverse=True)



#rankedPop = rankroutes(population)
#print("ranked pop: ",rankedPop)


# This function is to return parents route id's (based on input size) based on their fitness ranking
def selection(rankedpop,size):
    selectedParents =[]

    for i in range(0,size):
        selectedParents.append(rankedpop[i][0])

    for i in range(size,len(rankedpop)):

        selectedParents.append(rankedpop[i][0])


    return selectedParents

#selectedParents = selection(rankedPop,20)
#print("selectedParents",selectedParents)


# This function is to return the mating pool (list of parent routes)to generate next generation
def matingPool(population,selectedParents):
    matingPool=[]

    for index in selectedParents:
        matingPool.append(population[index])

    return matingPool


#matingPool= matingPool(population,selectedParents)

#print("Parent1 : No of cities: %d \n %s"%(len(matingPool[0]),matingPool[0]))
#print("Parent2 : No of cities: %d \n %s"%(len(matingPool[1]),matingPool[1]))



# This function returns a child by performing ordered cross over between parent 1 and 2 from the mating pool
def breed(parent1, parent2):
    child = []
    childP1 = []
    childP2 = []

    #Picking a random city index in the route of parent 1
    geneA = int(random.random() * len(parent1))

    #Picking a random city in the route of parent 2
    geneB = int(random.random() * len(parent1))
    #print("Gene A: %d Gene B: %d"%(geneA,geneB))

    #The starting index from where the cities would be inherited from the parent1 by the child
    startGene = min(geneA, geneB)
    #The end of index from where the cities would be inherited from the parent1 by the child
    endGene = max(geneA, geneB)

    #print("StartGene: %d, EndGene: %d"%(startGene,endGene))


    #Retaining the parent 1 gene from this logic
    for i in range(startGene, endGene):
        childP1.append(parent1[i])

    #print("ChildP1: ",childP1)


    #Rest of the cities would be picked from parent2 and since this is an ordered cross over function you need to pick cities that are not picked already and avoid duplicates
    childP2 = [item for item in parent2 if item not in childP1]

    #print("ChildP2: ",childP2)

    # Appending cities from parent1 and parent2 to form the final child route
    child = childP1 + childP2
    return child



# This function returns a child by performing ordered cross over between parent 1 and 2 from the mating pool
def breed2(parent1, parent2):
    child = []
    childP1 = []
    childP2 = []

    #Picking a random city index in the route of parent 1


    #Picking a random city in the route of parent 2

    #print("Gene A: %d Gene B: %d"%(geneA,geneB))

    #The starting index from where the cities would be inherited from the parent1 by the child
    startGene = 0
    #The end of index from where the cities would be inherited from the parent1 by the child
    endGene = math.floor(len(parent1)*0.25)

    #print("StartGene: %d, EndGene: %d"%(startGene,endGene))


    #Retaining the parent 1 gene from this logic
    for i in range(startGene, endGene):
        childP1.append(parent1[i])

    #print("ChildP1: ",childP1)


    #Rest of the cities would be picked from parent2 and since this is an ordered cross over function you need to pick cities that are not picked already and avoid duplicates
    childP2 = [item for item in parent2 if item not in childP1]

    #print("ChildP2: ",childP2)

    # Appending cities from parent1 and parent2 to form the final child route
    child = childP1 + childP2
    return child




def breedPopulation(matingpool, eliteSize):
    children = []
    length = len(matingpool) - eliteSize
    pool = random.sample(matingpool, len(matingpool))
    randomparentindex = random.randint(0,eliteSize)
    for i in range(0, eliteSize):
        children.append(matingpool[i])

    for i in range(0, length):
        child = breed(pool[randomparentindex], pool[len(matingpool) - i - 1])
        children.append(child)
    return children


def breedPopulation2(matingpool, eliteSize):
    children = []
    length = len(matingpool) - eliteSize
    pool = random.sample(matingpool, len(matingpool))

    for i in range(0, eliteSize):
        children.append(matingpool[i])

    for i in range(0, length):
        child = breed2(pool[i], pool[len(matingpool) - i - 1])
        children.append(child)
    return children




#print("Next Generation children: %d \n %s"%(len(children),children))



#Swap Mutation is followed as we need to abide by the rules for TSP i.e all the cities should be retained and shouldn't be duplicated
#Mutate function would take route and the rate of mutation required as an argument
def mutate(route, mutationRate):
    for swapped in range(len(route)):
        if (random.random() < mutationRate):

            swapWith = int(random.random() * len(route))
            #print("Swapping happening ")
            city1 = route[swapped]
            city2 = route[swapWith]

            route[swapped] = city2
            route[swapWith] = city1
    return route


#Mutate population would take the population as input and loop though the mutate function to generate all new childs
def mutatePopulation(population, mutationRate):
    mutatedPop = []
    for ind in range(0,5):
        mutatedPop.append(population[ind])
    for ind in range(5,len(population)):
        mutatedInd = mutate(population[ind], mutationRate)
        mutatedPop.append(mutatedInd)
    return mutatedPop




def nextGeneration(currentGeneration,elitesize,mutationRate):

    #print("CurrentGeneration Size: %d \n"%len(currentGeneration))
    #Rank the current population based on fitness
    rankedCurrentGen = rankroutes(currentGeneration)

    #print("Ranked current generation",rankedCurrentGen)
    #Select the top n(of input size) parents based on fitness results
    selectParentIds= selection(rankedCurrentGen,elitesize)

    #print("Selected Parents",selectParentIds)
    #Find the list of actual parent routes from their ID's
    matingParents= matingPool(currentGeneration,selectParentIds)


    #From the mating parents it will return childrens list of routes of size given in input
    childrenPop=breedPopulation(matingParents,elitesize)

    #The children are futher mutated to create a next generatiomn of population
    nextGeneration=mutatePopulation(childrenPop,mutationRate)

    return nextGeneration


def geneticAlgorithm(popsize,elitesize,mutationRate,generations):
    progress=[]



    #Returns a random population of routes[1..100]
    #No of routes returned is based on input size (popsize)
    pop = createPopulation(popsize)
    print(len(pop))
    #printRoute(pop)

    print(rankroutes(pop))
    print("Initial distance of the top route in the generation: " + str(distanceofRoute(pop[rankroutes(pop)[0][0]])))

    for i in range(0, generations):
        #sys.stdout.write("\rGeneration %i"%i)
        #sys.stdout.flush()
        #print("Generations",i)

        pop = nextGeneration(pop,elitesize, mutationRate)
        shortestDistofGen = distanceofRoute(pop[rankroutes(pop)[0][0]])

        sys.stdout.write("\rGeneration: %i Shortest distance of generation : %d" %(i,shortestDistofGen))
        sys.stdout.flush()
        progress.append(shortestDistofGen)
        if(shortestDistofGen < 300):
            print("Total distance of the below route is less than 1000 : Found route in Generation %d"%i)
            bestRouteIndex = rankroutes(pop)[0][0]
            bestRoute = pop[bestRouteIndex]
            print(bestRoute)
            print("Distance: ",shortestDistofGen)
            break;



    #print("Final distance of the top route in the generation: " + str(distanceofRoute(pop[rankroutes(pop)[0][0]])))
    timeinseconds = (time.time() - start_time)/60
    print("--- %d minutes taken to execute the program---" % timeinseconds)

    bestRouteIndex = rankroutes(pop)[0][0]
    bestRoute = pop[bestRouteIndex]
    bestRoute.append(bestRoute[0])

    crowds = findtoproutes(rankroutes(pop), 30, pop)
    aggregate(crowds,bestRoute[0])
    plotgraph(len(progress),coordslist,bestRoute)

    plt.plot(progress)
    plt.ylabel('Cost')
    plt.xlabel('Generation')
    plt.show()

    return bestRoute


#drawroute =[1, 71, 24, 89, 7, 36, 37, 38, 66, 21, 3, 41, 39, 53, 19, 91, 63, 32, 28, 61, 55, 46, 34, 86, 23, 96, 100, 45, 52, 22, 67, 27, 9, 82, 57, 44, 80, 58, 5, 42, 62, 50, 14, 76, 2, 48, 65, 88, 78, 26, 77, 87, 49, 11, 16, 70, 94, 75, 74, 17, 93, 99, 69, 47, 12, 18, 35, 4, 59, 33, 64, 31, 84, 40, 6, 20, 81, 98, 60, 25, 13, 56, 29, 97, 51, 8, 54, 90, 10, 83, 85, 72, 30, 73, 95, 15, 79, 68, 43, 92,1]

#plotgraph(coordslist,drawroute)





start_time = time.time()

    # First Argument -- number of routes in a population
    # Second Argument -- Elite Size to retain (how much of the top poulation are to be retained for next generation)
    # MutationRate -- Rate of Mutation
    # Fourth Argument -- How many generations the program can run?
bestRoute = geneticAlgorithm(50,20,0.0008,10000)
print(bestRoute)

print(distanceofRoute(bestRoute))
#np.savetxt("foo.csv", a, delimiter=",", fmt='%10.5f')
#a.tofile('foo.csv',sep=',')
#print("endtime",datetime.datetime.now())
#print(calmidpoint())

#coordslist.append(calmidpoint())

#plotpoints()

# Divide the group into 2 based on theta ordering
# GA is applied 5 times to create 20 different solutions


# plt.show()
# print(a[1,0])



# The crowds are the top 20 fittest individuals after 10,000 iterations
# Now integrate the results of these individuals
